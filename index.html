<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NEON DIVE // MATH OPS</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Impact, sans-serif; user-select: none; }
        canvas { display: block; }

        /* HUD */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* THE MATH PROBLEM */
        #equation-box {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); border: 2px solid #00ffff;
            padding: 10px 40px; border-radius: 10px;
            text-align: center; box-shadow: 0 0 30px rgba(0,255,255,0.3);
        }
        #equation-text { color: #fff; font-size: 60px; font-weight: bold; letter-spacing: 5px; text-shadow: 0 0 10px #00ffff; }
        #equation-label { color: #888; font-size: 14px; text-transform: uppercase; letter-spacing: 2px; }

        /* SCORE & STATS */
        .hud-text { position: absolute; color: #fff; font-weight: 900; font-style: italic; }
        #score-box { top: 30px; left: 40px; font-size: 24px; border-left: 5px solid #ff0055; padding-left: 15px; }
        #health-box { bottom: 30px; left: 40px; width: 300px; }
        #hp-bar { width: 100%; height: 10px; background: #333; border: 1px solid #fff; transform: skewX(-20deg); }
        #hp-fill { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s; box-shadow: 0 0 10px #00ff00; }
        
        /* FEEDBACK OVERLAYS */
        #feedback-msg {
            position: absolute; top: 40%; width: 100%; text-align: center;
            font-size: 100px; font-weight: 900; opacity: 0; transform: scale(0.5);
            transition: all 0.2s; text-shadow: 0 0 20px #fff;
        }
        
        /* SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5,5,10,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 50; transition: opacity 0.5s; backdrop-filter: blur(10px);
        }
        h1 { font-size: 100px; color: #fff; margin:0; text-shadow: 5px 5px 0 #ff0055, -5px -5px 0 #00ffff; }
        
        .btn {
            background: transparent; border: 2px solid #fff; color: #fff; padding: 20px 60px;
            font-size: 24px; font-weight: bold; cursor: pointer; margin-top: 40px;
            transition: 0.2s; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }
        .btn:hover { background: #fff; color: #000; box-shadow: 0 0 40px #00ffff; }

        .hidden { opacity: 0; pointer-events: none; }
        #vignette { position: fixed; width: 100%; height: 100%; box-shadow: inset 0 0 150px #000; pointer-events: none; z-index: 5; }
    </style>
</head>
<body>

    <div id="vignette"></div>

    <div id="ui-layer">
        <div id="equation-box">
            <div id="equation-label">SOLVE TO SURVIVE</div>
            <div id="equation-text">START</div>
        </div>

        <div id="score-box">SCORE: <span id="score-val">0</span></div>
        
        <div id="health-box">
            <div style="color:#fff; margin-bottom:5px;">HULL INTEGRITY</div>
            <div id="hp-bar"><div id="hp-fill"></div></div>
        </div>

        <div id="feedback-msg">CORRECT!</div>
    </div>

    <div id="menu" class="screen">
        <h1>MATH OPS</h1>
        <h2 style="color:#00ffff; letter-spacing: 5px;">HYPER-LEARNING MODULE</h2>
        <p style="color:#aaa; max-width: 500px; text-align: center;">
            Shoot the enemy with the CORRECT ANSWER.<br>
            Wrong answers damage your hull.<br>
            [ A / D ] Move &nbsp;|&nbsp; [ SPACE ] Shoot
        </p>
        <button class="btn" id="btn-start">INITIATE</button>
    </div>

    <div id="gameover" class="screen hidden">
        <h1 style="color:#ff0055">FAIL</h1>
        <h2 style="color:#fff">SCORE: <span id="final-score">0</span></h2>
        <button class="btn" id="btn-restart">RETRY</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- MATH ENGINE ---
        const MathSys = {
            level: 1,
            currentQ: "",
            currentA: 0,
            
            generate() {
                // Difficulty scaling
                const type = this.level < 4 ? 'add' : this.level < 8 ? 'mult' : 'mix';
                let a, b, op, qStr, ans;

                if (type === 'add') {
                    // Addition / Subtraction
                    op = Math.random() > 0.5 ? '+' : '-';
                    a = Math.floor(Math.random() * 10 * this.level) + 1;
                    b = Math.floor(Math.random() * 10 * this.level) + 1;
                    if (op === '-') { if(a < b) [a, b] = [b, a]; } // No negatives yet
                    ans = op === '+' ? a + b : a - b;
                    qStr = `${a} ${op} ${b}`;
                } else if (type === 'mult') {
                    // Multiplication
                    a = Math.floor(Math.random() * (this.level)) + 2;
                    b = Math.floor(Math.random() * 10) + 2;
                    ans = a * b;
                    qStr = `${a} x ${b}`;
                } else {
                    // Division / Mixed
                    const ops = ['+', '-', 'x', '/'];
                    op = ops[Math.floor(Math.random()*4)];
                    if(op === '/') {
                        b = Math.floor(Math.random() * 9) + 2;
                        ans = Math.floor(Math.random() * 10) + 1;
                        a = b * ans; // Ensure clean division
                    } else if (op === 'x') {
                        a = Math.floor(Math.random() * 12); b = Math.floor(Math.random() * 12);
                        ans = a * b;
                    } else {
                        a = Math.floor(Math.random() * 50); b = Math.floor(Math.random() * 50);
                        if(op==='-' && a<b) [a,b] = [b,a];
                        ans = op==='+' ? a+b : a-b;
                    }
                    qStr = `${a} ${op} ${b}`;
                }

                this.currentQ = qStr + " = ?";
                this.currentA = ans;
                
                // UI Update
                document.getElementById('equation-text').innerText = this.currentQ;
                document.getElementById('equation-text').style.color = "#fff";
                
                return { q: qStr, a: ans };
            },

            getAnswers() {
                // Returns [Correct, Wrong1, Wrong2]
                const correct = this.currentA;
                let w1 = correct + Math.floor(Math.random() * 5) + 1;
                let w2 = correct - Math.floor(Math.random() * 5) - 1;
                if(w1 === correct) w1 += 2;
                if(w2 === correct) w2 -= 2;
                
                // Shuffle
                const arr = [{val: correct, isCorrect: true}, {val: w1, isCorrect: false}, {val: w2, isCorrect: false}];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }
        };

        // --- GRAPHICS HELPER ---
        function createTextTexture(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = '#111';
            ctx.fillRect(0,0,256,256);
            
            // Border
            ctx.lineWidth = 10;
            ctx.strokeStyle = color;
            ctx.strokeRect(5,5,246,246);
            
            // Text
            ctx.fillStyle = color;
            ctx.font = 'bold 100px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 128);
            
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // --- CORE ENGINE ---
        const Game = {
            scene: null, camera: null, renderer: null, composer: null,
            state: 'MENU',
            enemies: [], bullets: [], particles: [],
            lanes: [-5, 0, 5], targetLane: 0,
            score: 0, hp: 100,
            
            init() {
                // Scene Setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000510, 0.02);
                
                this.camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 3, 6);
                
                this.renderer = new THREE.WebGLRenderer({antialias:false});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);
                
                // Post Processing
                const renderPass = new RenderPass(this.scene, this.camera);
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.strength = 1.5; bloom.radius = 0.5;
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(renderPass);
                this.composer.addPass(bloom);
                
                // Inputs
                document.addEventListener('keydown', e => {
                    if(this.state !== 'RUN') return;
                    if(e.key === 'a' || e.key === 'ArrowLeft') this.targetLane = Math.max(-1, this.targetLane-1);
                    if(e.key === 'd' || e.key === 'ArrowRight') this.targetLane = Math.min(1, this.targetLane+1);
                    if(e.key === ' ' || e.key === 'w') this.shoot();
                });
                
                document.getElementById('btn-start').onclick = () => this.start();
                document.getElementById('btn-restart').onclick = () => this.start();
                
                this.buildWorld();
                this.buildPlayer();
                this.animate();
            },

            buildWorld() {
                // Grid
                const grid = new THREE.GridHelper(200, 50, 0x00ffff, 0x220033);
                grid.position.y = -2;
                this.scene.add(grid);
                this.grid = grid;
                
                // Moving Stars
                const geo = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<1000; i++) pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*50, (Math.random()-0.5)*200);
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                this.stars = new THREE.Points(geo, new THREE.PointsMaterial({color:0xffffff, size:0.2}));
                this.scene.add(this.stars);
            },

            buildPlayer() {
                this.player = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color:0x222222, emissive:0x00ffff, emissiveIntensity:0.5});
                
                const body = new THREE.Mesh(new THREE.ConeGeometry(0.5, 2, 4), mat);
                body.rotation.x = Math.PI/2;
                this.player.add(body);
                
                const wing = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 1), mat);
                wing.position.z = 0.5;
                this.player.add(wing);
                
                this.scene.add(this.player);
                this.playerX = 0;
                this.playerTilt = 0;
            },

            start() {
                this.state = 'RUN';
                this.score = 0;
                this.hp = 100;
                this.waveTimer = 0;
                MathSys.level = 1;
                
                // UI Reset
                document.getElementById('menu').classList.add('hidden');
                document.getElementById('gameover').classList.add('hidden');
                this.updateUI();
                
                // Clear scene
                this.enemies.forEach(e => this.scene.remove(e.mesh));
                this.enemies = [];
                
                MathSys.generate();
                this.spawnWave();
            },

            spawnWave() {
                const answers = MathSys.getAnswers(); // [ {val:4, isCorrect:true}, ... ]
                
                answers.forEach((ans, i) => {
                    const color = '#ff0055'; // All look red initially (difficulty) or maybe blue? Let's use blue/cyan
                    const tex = createTextTexture(ans.val.toString(), '#00ffff');
                    
                    const geo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
                    const mat = new THREE.MeshBasicMaterial({ map: tex });
                    const mesh = new THREE.Mesh(geo, mat);
                    
                    mesh.position.set(this.lanes[i], 0, -150);
                    this.scene.add(mesh);
                    
                    this.enemies.push({
                        mesh: mesh,
                        data: ans,
                        active: true
                    });
                });
            },

            shoot() {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 2);
                const mat = new THREE.MeshBasicMaterial({color: 0xffff00});
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(this.player.position);
                mesh.position.y = 0; // Shoot from center
                this.scene.add(mesh);
                this.bullets.push({mesh: mesh, vel: -5});
                
                // Audio placeholder
            },

            createExplosion(pos, color) {
                for(let i=0; i<15; i++) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshBasicMaterial({color:color}));
                    m.position.copy(pos);
                    const v = new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
                    this.scene.add(m);
                    this.particles.push({mesh:m, vel:v, life:1.0});
                }
            },

            feedback(text, color) {
                const el = document.getElementById('feedback-msg');
                el.innerText = text;
                el.style.color = color;
                el.style.opacity = 1;
                el.style.transform = "scale(1.2)";
                setTimeout(() => {
                    el.style.opacity = 0;
                    el.style.transform = "scale(0.5)";
                }, 800);
            },

            updateUI() {
                document.getElementById('score-val').innerText = this.score;
                document.getElementById('hp-fill').style.width = this.hp + "%";
            },

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.state === 'RUN') {
                    // 1. Move Environment
                    this.grid.position.z += 0.8;
                    if(this.grid.position.z > 0) this.grid.position.z = -50;
                    
                    const stars = this.stars.geometry.attributes.position.array;
                    for(let i=2; i<stars.length; i+=3) {
                        stars[i] += 4; // Star speed
                        if(stars[i] > 20) stars[i] = -200;
                    }
                    this.stars.geometry.attributes.position.needsUpdate = true;

                    // 2. Move Player
                    const tx = this.lanes[this.targetLane+1];
                    this.playerX += (tx - this.playerX) * 0.15;
                    this.player.position.x = this.playerX;
                    this.playerTilt += (-(this.player.position.x - tx)*0.5 - this.playerTilt) * 0.1;
                    this.player.rotation.z = this.playerTilt;

                    // 3. Move Enemies
                    let waveCleared = false;
                    for(let i=this.enemies.length-1; i>=0; i--) {
                        const e = this.enemies[i];
                        e.mesh.position.z += 0.8; // Enemy Speed
                        
                        // Collision with Player
                        if(e.mesh.position.distanceTo(this.player.position) < 2.5) {
                            this.scene.remove(e.mesh);
                            this.enemies.splice(i, 1);
                            this.hp -= 20;
                            this.feedback("CRASH!", "#ff0000");
                            this.updateUI();
                        }
                        // Missed Enemy
                        else if(e.mesh.position.z > 5) {
                            this.scene.remove(e.mesh);
                            this.enemies.splice(i, 1);
                        }
                    }
                    
                    // Spawn new wave if empty
                    if(this.enemies.length === 0) {
                        this.spawnWave();
                    }

                    // 4. Bullets
                    for(let i=this.bullets.length-1; i>=0; i--) {
                        const b = this.bullets[i];
                        b.mesh.position.z += b.vel;
                        
                        // Hit detection
                        let hit = false;
                        for(let j=this.enemies.length-1; j>=0; j--) {
                            const e = this.enemies[j];
                            if(b.mesh.position.distanceTo(e.mesh.position) < 3) {
                                // HIT!
                                hit = true;
                                this.createExplosion(e.mesh.position, e.data.isCorrect ? 0x00ff00 : 0xff0000);
                                this.scene.remove(e.mesh);
                                this.enemies.splice(j, 1);
                                
                                if(e.data.isCorrect) {
                                    // CORRECT ANSWER
                                    this.score += 100 * MathSys.level;
                                    MathSys.level = Math.floor(this.score/500) + 1;
                                    this.feedback("CORRECT!", "#00ff00");
                                    
                                    // Clear remaining wrong answers
                                    this.enemies.forEach(rem => this.scene.remove(rem.mesh));
                                    this.enemies = [];
                                    
                                    MathSys.generate();
                                    setTimeout(() => this.spawnWave(), 500);
                                } else {
                                    // WRONG ANSWER
                                    this.hp -= 15;
                                    this.feedback("WRONG!", "#ff0000");
                                }
                                this.updateUI();
                                break;
                            }
                        }
                        
                        if(hit || b.mesh.position.z < -200) {
                            this.scene.remove(b.mesh);
                            this.bullets.splice(i, 1);
                        }
                    }

                    // 5. Particles
                    for(let i=this.particles.length-1; i>=0; i--) {
                        const p = this.particles[i];
                        p.mesh.position.addScaledVector(p.vel, 0.016);
                        p.life -= 0.05;
                        p.mesh.scale.setScalar(p.life);
                        if(p.life <= 0) {
                            this.scene.remove(p.mesh);
                            this.particles.splice(i,1);
                        }
                    }
                    
                    // Game Over
                    if(this.hp <= 0) {
                        this.state = 'GAMEOVER';
                        document.getElementById('gameover').classList.remove('hidden');
                        document.getElementById('final-score').innerText = this.score;
                    }
                }
                
                this.composer.render();
            }
        };

        Game.init();
    </script>
</body>
</html>
