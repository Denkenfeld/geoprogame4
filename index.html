<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NEON DIVE // MATH WARRIOR</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }

        /* HUD */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        /* MATH DISPLAY (Top Center) */
        #math-panel {
            position: absolute; top: 5%; left: 50%; transform: translateX(-50%);
            text-align: center; width: 100%;
        }
        #math-problem {
            font-size: 100px; font-weight: 900; color: #fff;
            text-shadow: 0 0 30px #00ffff; margin: 0;
            display: inline-block; background: rgba(0,0,0,0.5);
            padding: 10px 50px; border-radius: 20px; border: 1px solid #00ffff;
            backdrop-filter: blur(5px); transition: transform 0.2s;
        }
        .pulse { animation: pulse 0.5s; }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.1);} 100% {transform: scale(1);} }

        /* STATS */
        .hud-text { position: absolute; color: #fff; font-weight: bold; font-size: 24px; text-shadow: 0 0 10px #000; }
        #score-display { top: 30px; left: 40px; border-left: 5px solid #ff0055; padding-left: 15px; }
        #weapon-display { top: 30px; right: 40px; border-right: 5px solid #ffcc00; padding-right: 15px; color: #ffcc00; text-align: right; }
        
        /* BOSS HEALTH */
        #boss-hud {
            position: absolute; top: 150px; left: 50%; transform: translateX(-50%);
            width: 500px; display: none;
        }
        #boss-name { text-align: center; color: #ff0055; font-size: 20px; letter-spacing: 5px; font-weight: bold; margin-bottom: 5px; }
        #boss-bar-track { width: 100%; height: 20px; background: #220000; border: 2px solid #ff0055; }
        #boss-bar-fill { width: 100%; height: 100%; background: #ff0055; transition: width 0.1s; }

        /* SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5,5,10,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 50; transition: opacity 0.5s;
        }
        h1 { font-size: 100px; color: #fff; margin: 0; text-shadow: 0 0 40px #00ffff; }
        h2 { color: #888; letter-spacing: 5px; margin-bottom: 40px; }
        
        .btn {
            background: transparent; border: 2px solid #fff; color: #fff; padding: 20px 60px;
            font-size: 24px; font-weight: bold; cursor: pointer; transition: 0.2s;
        }
        .btn:hover { background: #fff; color: #000; box-shadow: 0 0 40px #00ffff; }
        .btn:disabled { opacity: 0.5; cursor: wait; border-color: #555; color: #555; }

        /* UPGRADE MENU */
        #upgrade-menu { background: rgba(0,0,0,0.9); }
        .card { border: 1px solid #444; padding: 30px; text-align: center; width: 300px; }
        .card-title { color: #ffcc00; font-size: 24px; font-weight: bold; margin-bottom: 10px; }
        .card-level { color: #fff; font-size: 14px; margin-bottom: 20px; }
        
        .hidden { opacity: 0; pointer-events: none; }
        #loading { position: absolute; bottom: 20px; width: 100%; text-align: center; color: #00ffff; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div id="math-panel">
            <div style="color:#aaa; letter-spacing:3px; font-weight:bold; margin-bottom:5px;">COURSE CALCULATION</div>
            <div id="math-problem">LOADING...</div>
        </div>

        <div id="score-display">SCORE: 0</div>
        <div id="weapon-display">
            WEAPON LEVEL: <span id="wep-level-hud">1</span><br>
            <span style="font-size:14px; color:#888;">UPGRADES SAVED</span>
        </div>

        <div id="boss-hud">
            <div id="boss-name">SECTOR GUARDIAN</div>
            <div id="boss-bar-track"><div id="boss-bar-fill"></div></div>
        </div>
    </div>

    <div id="menu" class="screen">
        <h1>MATH WARRIOR</h1>
        <h2>PERSISTENT ARSENAL</h2>
        <div style="text-align: center; line-height: 1.6; color: #ccc; margin-bottom: 30px; font-size: 18px;">
            1. <b>FLY THROUGH</b> the correct answer.<br>
            2. Defeat the <b>BOSS</b> every 5 rounds.<br>
            3. <b>UPGRADE</b> weapons. (Saved after death)<br>
        </div>
        <button class="btn" id="btn-start" disabled>LOADING ASSETS...</button>
        <div id="loading">DOWNLOADING 3D FONTS...</div>
    </div>

    <div id="upgrade-screen" class="screen hidden">
        <h1 style="color: #ffcc00;">ARMORY</h1>
        <p style="color:#aaa; margin-bottom: 30px;">BOSS DEFEATED. WEAPONS UPGRADED.</p>
        
        <div class="card">
            <div class="card-title">PLASMA CANNONS</div>
            <div class="card-level">CURRENT LEVEL: <span id="shop-level">1</span></div>
            <div style="color:#00ffff; margin-bottom: 20px;">DAMAGE INCREASED</div>
            <button class="btn" onclick="Game.nextLevel()">NEXT SECTOR</button>
        </div>
    </div>

    <div id="gameover" class="screen hidden">
        <h1 style="color:#ff0055;">HULL CRITICAL</h1>
        <h2 style="color:#fff;">WEAPON LEVEL SAVED.</h2>
        <button class="btn" onclick="Game.reset()">RESPAWN</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        /* --- GAME ENGINE --- */
        const Game = {
            state: 'LOADING', // LOADING, MENU, MATH, BOSS, UPGRADE, OVER
            score: 0,
            level: 1, // Math difficulty
            qCount: 0, // Questions answered in this run
            
            // Player Stats
            weaponLevel: 1, // SAVED IN LOCALSTORAGE
            
            // Scene Objects
            font: null,
            answers: [], // The 3D numbers
            bullets: [],
            enemyBullets: [],
            boss: null,
            
            // Settings
            lanes: [-8, 0, 8],
            targetLane: 0,
            
            init() {
                // 1. Load Save
                const saved = localStorage.getItem('neon_warrior_save');
                if(saved) this.weaponLevel = parseInt(saved);
                this.updateHUD();

                // 2. Setup 3D
                Scene.init();
                
                // 3. Load Font
                const loader = new FontLoader();
                loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
                    this.font = font;
                    this.state = 'MENU';
                    const btn = document.getElementById('btn-start');
                    btn.innerText = "LAUNCH SHIP";
                    btn.disabled = false;
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('math-problem').innerText = "READY";
                });

                // 4. Inputs
                document.getElementById('btn-start').onclick = () => this.startRun();
                
                document.addEventListener('keydown', (e) => {
                    if(this.state !== 'MATH' && this.state !== 'BOSS') return;
                    
                    if(e.key === 'a' || e.key === 'ArrowLeft') this.targetLane = Math.max(-1, this.targetLane - 1);
                    if(e.key === 'd' || e.key === 'ArrowRight') this.targetLane = Math.min(1, this.targetLane + 1);
                    if(e.key === ' ' || e.key === 'w') {
                        if(this.state === 'BOSS') this.shoot(); // Only shoot in boss mode
                    }
                });

                this.loop();
            },

            startRun() {
                this.score = 0;
                this.level = 1;
                this.qCount = 0;
                this.updateHUD();
                Player.create(); // Rebuild ship based on weapon level
                
                this.ui('menu', false);
                this.ui('gameover', false);
                
                this.startMathPhase();
            },

            startMathPhase() {
                this.state = 'MATH';
                this.clearScene();
                document.getElementById('math-panel').style.opacity = 1;
                document.getElementById('boss-hud').style.display = 'none';
                
                this.spawnQuestion();
            },

            startBossPhase() {
                this.state = 'BOSS';
                this.clearScene();
                document.getElementById('math-panel').style.opacity = 0; // Hide math
                
                // Spawn Boss
                Boss.spawn(this.level);
                document.getElementById('boss-hud').style.display = 'block';
            },

            spawnQuestion() {
                const q = MathGen.generate(this.level);
                const opts = MathGen.getOptions(q.a);
                
                document.getElementById('math-problem').innerText = q.q + " = ?";
                document.getElementById('math-problem').classList.add('pulse');
                setTimeout(()=>document.getElementById('math-problem').classList.remove('pulse'), 500);

                // Create 3D Numbers
                opts.forEach((opt, i) => {
                    const geo = new TextGeometry(opt.val.toString(), {
                        font: this.font,
                        size: 3,
                        height: 1,
                        curveSegments: 12
                    });
                    geo.computeBoundingBox();
                    geo.center(); // Center the pivot

                    const mat = new THREE.MeshStandardMaterial({
                        color: 0x00ffff, 
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.5,
                        roughness: 0.2
                    });
                    
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(this.lanes[i], 0, -300); // Far away
                    
                    // Hitbox wrapper (invisible box for easier collision)
                    const box = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), new THREE.MeshBasicMaterial({visible:false}));
                    box.position.copy(mesh.position);
                    
                    Scene.scene.add(mesh);
                    // We don't add hitbox to scene, just use it for logic or attach it
                    mesh.userData = { isCorrect: opt.isCorrect, val: opt.val };
                    this.answers.push(mesh);
                });
            },

            shoot() {
                // Number of bullets based on weapon level
                const shots = [];
                const p = Player.mesh.position;
                
                // Center shot
                shots.push({x:0, z:0});
                
                if(this.weaponLevel >= 2) { shots.push({x:-1.5, z:0.5}); shots.push({x:1.5, z:0.5}); }
                if(this.weaponLevel >= 5) { shots.push({x:-0.8, z:0}); shots.push({x:0.8, z:0}); }

                shots.forEach(s => {
                    const geo = new THREE.BoxGeometry(0.3, 0.3, 2);
                    const mat = new THREE.MeshBasicMaterial({color: 0xff0055});
                    const b = new THREE.Mesh(geo, mat);
                    b.position.set(p.x + s.x, p.y, p.z - 2);
                    Scene.scene.add(b);
                    this.bullets.push({mesh: b, vel: -4});
                });
            },

            checkCollision() {
                const pPos = Player.mesh.position;

                // 1. Math Phase: Player vs Numbers
                if(this.state === 'MATH') {
                    for(let i=this.answers.length-1; i>=0; i--) {
                        const ans = this.answers[i];
                        // Move answer
                        ans.position.z += 1.0; // Speed of approach
                        ans.rotation.x += 0.01;
                        ans.rotation.y += 0.01;

                        // Collision Check (Simple distance)
                        if(ans.position.distanceTo(pPos) < 4) {
                            if(ans.userData.isCorrect) {
                                // Correct!
                                this.score += 100;
                                this.qCount++;
                                Effects.explode(ans.position, 0x00ff00);
                                this.clearScene(); // Remove numbers
                                
                                if(this.qCount % 5 === 0) {
                                    this.startBossPhase();
                                } else {
                                    setTimeout(() => this.spawnQuestion(), 500);
                                }
                            } else {
                                // Wrong!
                                Effects.explode(pPos, 0xff0000);
                                this.gameOver();
                            }
                            this.updateHUD();
                            return; // Stop checking
                        }

                        // Missed
                        if(ans.position.z > 10) {
                            if(ans.userData.isCorrect) this.gameOver(); // Missed correct answer
                            else {
                                Scene.scene.remove(ans);
                                this.answers.splice(i, 1);
                            }
                        }
                    }
                }

                // 2. Boss Phase: Bullets vs Boss
                if(this.state === 'BOSS' && this.boss) {
                    // Boss Move
                    this.boss.mesh.position.x = Math.sin(Date.now() * 0.001) * 10;

                    // Boss Shoot (Randomly)
                    if(Math.random() < 0.02) Boss.shoot();

                    // Update Player Bullets
                    for(let i=this.bullets.length-1; i>=0; i--) {
                        const b = this.bullets[i];
                        b.mesh.position.z += b.vel;
                        
                        if(b.mesh.position.distanceTo(this.boss.mesh.position) < 5) {
                            // Hit Boss
                            Effects.explode(b.mesh.position, 0xffaa00);
                            Boss.hp -= (this.weaponLevel * 5); // Dmg scales with level
                            Boss.updateHUD();
                            Scene.scene.remove(b.mesh);
                            this.bullets.splice(i, 1);

                            if(Boss.hp <= 0) {
                                this.bossDefeated();
                            }
                            continue;
                        }
                        
                        if(b.mesh.position.z < -300) {
                            Scene.scene.remove(b.mesh);
                            this.bullets.splice(i, 1);
                        }
                    }

                    // Update Enemy Bullets
                    for(let i=this.enemyBullets.length-1; i>=0; i--) {
                        const b = this.enemyBullets[i];
                        b.mesh.position.z += b.vel;
                        
                        if(b.mesh.position.distanceTo(pPos) < 2) {
                            // Player Hit
                            Effects.explode(pPos, 0xff0000);
                            this.gameOver();
                        }
                        if(b.mesh.position.z > 10) {
                            Scene.scene.remove(b.mesh);
                            this.enemyBullets.splice(i, 1);
                        }
                    }
                }
            },

            bossDefeated() {
                Effects.explode(this.boss.mesh.position, 0x00ffff, 50); // Big boom
                Scene.scene.remove(this.boss.mesh);
                this.boss = null;
                this.enemyBullets.forEach(b => Scene.scene.remove(b.mesh));
                this.enemyBullets = [];
                
                // Upgrade Weapon
                this.weaponLevel++;
                localStorage.setItem('neon_warrior_save', this.weaponLevel);
                
                this.state = 'UPGRADE';
                this.ui('upgrade-screen', true);
                document.getElementById('shop-level').innerText = this.weaponLevel;
            },

            nextLevel() {
                this.ui('upgrade-screen', false);
                this.level++; // Harder math
                Player.create(); // Show new guns
                this.updateHUD();
                this.startMathPhase();
            },

            gameOver() {
                this.state = 'OVER';
                this.ui('gameover', true);
            },

            reset() {
                this.startRun();
            },

            clearScene() {
                this.answers.forEach(m => Scene.scene.remove(m)); this.answers = [];
                this.bullets.forEach(m => Scene.scene.remove(m.mesh)); this.bullets = [];
                this.enemyBullets.forEach(m => Scene.scene.remove(m.mesh)); this.enemyBullets = [];
            },

            updateHUD() {
                document.getElementById('score-display').innerText = "SCORE: " + this.score;
                document.getElementById('wep-level-hud').innerText = this.weaponLevel;
            },

            ui(id, show) {
                document.getElementById(id).classList.toggle('hidden', !show);
            },

            loop() {
                requestAnimationFrame(() => this.loop());
                
                const dt = 0.016;

                // Move Player
                if(this.state === 'MATH' || this.state === 'BOSS') {
                    const tx = this.lanes[this.targetLane+1];
                    Player.mesh.position.x += (tx - Player.mesh.position.x) * 0.1;
                    Player.mesh.rotation.z = -(Player.mesh.position.x - tx) * 0.05;
                    
                    this.checkCollision();
                }

                // Move Environment
                Scene.update();
                Effects.update();

                Scene.composer.render();
            }
        };

        /* --- PLAYER SHIP --- */
        const Player = {
            mesh: null,
            create() {
                if(this.mesh) Scene.scene.remove(this.mesh);
                this.mesh = new THREE.Group();

                // Main Body
                const mat = new THREE.MeshStandardMaterial({color: 0x222222, emissive: 0x00ffff, emissiveIntensity: 0.5});
                const body = new THREE.Mesh(new THREE.ConeGeometry(0.8, 3, 4), mat);
                body.rotation.x = Math.PI/2;
                this.mesh.add(body);

                const wings = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 1.5), mat);
                wings.position.z = 0.5;
                this.mesh.add(wings);

                // VISUAL WEAPONS based on Level
                const gunGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.5);
                const gunMat = new THREE.MeshBasicMaterial({color: 0xff0055});
                
                // Lvl 1: Center
                const g1 = new THREE.Mesh(gunGeo, gunMat);
                g1.rotation.x = Math.PI/2; g1.position.set(0, -0.2, -0.5);
                this.mesh.add(g1);

                if(Game.weaponLevel >= 2) {
                    const g2 = g1.clone(); g2.position.set(-1.5, 0, 0.5); this.mesh.add(g2);
                    const g3 = g1.clone(); g3.position.set(1.5, 0, 0.5); this.mesh.add(g3);
                }
                
                if(Game.weaponLevel >= 5) {
                    const g4 = g1.clone(); g4.scale.set(2,2,2); g4.position.set(0, 0.5, 0);
                    this.mesh.add(g4);
                }

                Scene.scene.add(this.mesh);
            }
        };

        /* --- BOSS LOGIC --- */
        const Boss = {
            mesh: null,
            hp: 100, maxHp: 100,
            
            spawn(level) {
                this.maxHp = 100 * level;
                this.hp = this.maxHp;
                
                const geo = new THREE.DodecahedronGeometry(3);
                const mat = new THREE.MeshStandardMaterial({color: 0x440000, emissive: 0xff0000, emissiveIntensity: 1, wireframe: true});
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.set(0, 2, -50);
                
                // Inner core
                const core = new THREE.Mesh(new THREE.IcosahedronGeometry(1.5, 2), new THREE.MeshBasicMaterial({color: 0xffffff}));
                this.mesh.add(core);
                
                Scene.scene.add(this.mesh);
                Game.boss = this;
                this.updateHUD();
            },

            shoot() {
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color: 0xff0000}));
                b.position.copy(this.mesh.position);
                Scene.scene.add(b);
                Game.enemyBullets.push({mesh: b, vel: 0.5}); // Slow bullet
            },

            updateHUD() {
                document.getElementById('boss-bar-fill').style.width = (this.hp / this.maxHp * 100) + "%";
            }
        };

        /* --- MATH GENERATOR --- */
        const MathGen = {
            generate(level) {
                // Harder math as levels go up
                let n1, n2, op, a;
                if(level <= 1) {
                    n1 = r(10); n2 = r(10); op='+'; a = n1+n2;
                } else if(level <= 3) {
                    n1 = r(20); n2 = r(10); op=Math.random()>.5?'+':'-'; a = op==='+'?n1+n2 : n1-n2;
                } else {
                    n1 = r(10)+2; n2 = r(9)+2; op='x'; a = n1*n2;
                }
                return {q: `${n1} ${op} ${n2}`, a: a};
            },
            getOptions(ans) {
                let w1 = ans + r(5) + 1;
                let w2 = ans - r(5) - 1;
                if(w1==ans) w1++; if(w2==ans) w2--;
                return [{val:ans, isCorrect:true}, {val:w1, isCorrect:false}, {val:w2, isCorrect:false}].sort(()=>Math.random()-.5);
            }
        };
        function r(n) { return Math.floor(Math.random()*n)+1; }

        /* --- SCENE & VISUALS --- */
        const Scene = {
            init() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.02);
                
                this.camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 5, 10);
                this.camera.lookAt(0,0,-50);

                this.renderer = new THREE.WebGLRenderer({antialias: true});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);
                
                // Bloom
                const composer = new EffectComposer(this.renderer);
                composer.addPass(new RenderPass(this.scene, this.camera));
                composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));
                this.composer = composer;

                // Lighting
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(0, 10, 5);
                this.scene.add(light);
                this.scene.add(new THREE.AmbientLight(0x404040));

                // Environment
                this.createStars();
                this.createGrid();

                window.onresize = () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                }
            },
            createStars() {
                const geo = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<2000; i++) pos.push((Math.random()-.5)*400, (Math.random()-.5)*200, (Math.random()-.5)*400);
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                this.stars = new THREE.Points(geo, new THREE.PointsMaterial({color:0xffffff, size:0.5}));
                this.scene.add(this.stars);
            },
            createGrid() {
                this.grid = new THREE.GridHelper(500, 100, 0x00ffff, 0x110022);
                this.grid.position.y = -5;
                this.scene.add(this.grid);
            },
            update() {
                this.grid.position.z += 1;
                if(this.grid.position.z > 0) this.grid.position.z = -50;
                
                const s = this.stars.geometry.attributes.position.array;
                for(let i=2; i<s.length; i+=3) {
                    s[i] += 5;
                    if(s[i] > 50) s[i] = -300;
                }
                this.stars.geometry.attributes.position.needsUpdate = true;
            }
        };

        const Effects = {
            particles: [],
            explode(pos, color) {
                for(let i=0; i<10; i++) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color:color}));
                    m.position.copy(pos);
                    m.userData = { vel: new THREE.Vector3((Math.random()-.5)*10, (Math.random()-.5)*10, (Math.random()-.5)*10), life: 1.0 };
                    Scene.scene.add(m);
                    this.particles.push(m);
                }
            },
            update() {
                for(let i=this.particles.length-1; i>=0; i--) {
                    const p = this.particles[i];
                    p.position.addScaledVector(p.userData.vel, 0.05);
                    p.userData.life -= 0.05;
                    p.scale.setScalar(p.userData.life);
                    if(p.userData.life <= 0) {
                        Scene.scene.remove(p);
                        this.particles.splice(i,1);
                    }
                }
            }
        };

        Game.init();
    </script>
</body>
</html>
