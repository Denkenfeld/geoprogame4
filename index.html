<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NEON DIVE // OMEGA (BALANCED)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }

        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .hud-panel { position: absolute; color: #fff; font-weight: 800; font-style: italic; text-shadow: 0 0 5px rgba(0,0,0,0.8); }
        #score-hud { top: 30px; left: 40px; font-size: 24px; border-left: 4px solid #00ffff; padding-left: 15px; }
        #currency-hud { top: 30px; right: 40px; font-size: 24px; color: #ffcc00; border-right: 4px solid #ffcc00; padding-right: 15px; }
        
        /* BOSS BAR */
        #boss-frame {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%); width: 50%; height: 10px;
            background: rgba(0,0,0,0.8); border: 1px solid #ff0055; display: none;
        }
        #boss-bar { width: 100%; height: 100%; background: #ff0055; box-shadow: 0 0 10px #ff0055; transition: width 0.2s; }
        #boss-label { position: absolute; top: -25px; width: 100%; text-align: center; color: #ff0055; font-weight: bold; letter-spacing: 3px; }

        /* SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 20; transition: opacity 0.5s;
        }

        h1 { font-size: 80px; margin: 0; color: #fff; text-shadow: 0 0 20px #00ffff; font-style: italic; }
        
        .btn-main {
            background: transparent; border: 2px solid #fff; color: #fff; padding: 15px 50px;
            font-size: 20px; font-weight: 900; letter-spacing: 2px; cursor: pointer; margin-top: 40px;
            transition: 0.2s;
        }
        .btn-main:hover { background: #fff; color: #000; box-shadow: 0 0 20px #00ffff; }

        /* SHOP */
        .upgrade-grid { display: flex; gap: 20px; margin-top: 40px; }
        .card {
            background: rgba(255,255,255,0.05); border: 1px solid #444; padding: 20px; width: 180px; text-align: center;
            transition: 0.2s;
        }
        .card:hover { border-color: #00ffff; background: rgba(0,255,255,0.1); }
        .card h3 { color: #00ffff; font-size: 16px; margin-bottom: 5px; }
        .price { font-size: 20px; color: #ffcc00; font-weight: bold; margin: 10px 0; }
        .buy-btn { width: 100%; padding: 8px; cursor: pointer; background: #222; border: 1px solid #555; color: #fff; }
        .buy-btn:hover:enabled { background: #00ffff; color: #000; }

        #damage-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;
            transition: box-shadow 0.1s; mix-blend-mode: overlay; z-index: 5;
        }
        
        .hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>

    <div id="ui-layer">
        <div id="score-hud">SECTOR 01</div>
        <div id="currency-hud">0 FRAGMENTS</div>
        <div id="boss-frame">
            <div id="boss-label">GUARDIAN</div>
            <div id="boss-bar"></div>
        </div>
    </div>

    <div id="menu" class="screen">
        <h1>NEON DIVE</h1>
        <h2 style="color:#ff0055; letter-spacing: 5px; margin-top:-10px;">OMEGA</h2>
        <button class="btn-main" id="start-btn">JACK IN</button>
    </div>

    <div id="shop" class="screen hidden">
        <h1 style="font-size: 50px; color: #ff0055;">SYNC FAILED</h1>
        <div style="color: #ffcc00; margin: 20px;">FRAGMENTS: <span id="shop-frags">0</span></div>
        <div class="upgrade-grid">
            <div class="card">
                <h3>MAGNET</h3>
                <div class="lvl">Lvl <span id="lvl-mag">0</span></div>
                <div class="price" id="cost-mag">10</div>
                <button class="buy-btn" onclick="Game.buy('magnet')">BUY</button>
            </div>
            <div class="card">
                <h3>WEAPON</h3>
                <div class="lvl">Lvl <span id="lvl-wep">0</span></div>
                <div class="price" id="cost-wep">10</div>
                <button class="buy-btn" onclick="Game.buy('weapon')">BUY</button>
            </div>
            <div class="card">
                <h3>SHIELD</h3>
                <div class="lvl" id="lvl-shi">OFFLINE</div>
                <div class="price" id="cost-shi">50</div>
                <button class="buy-btn" onclick="Game.buy('shield')">BUY</button>
            </div>
        </div>
        <button class="btn-main" id="respawn-btn">REBOOT</button>
    </div>

    <div id="endgame" class="screen hidden">
        <h1>TRANSCENDENCE</h1>
        <p>YOU HAVE REACHED THE SINGULARITY.</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- GAME STATE ---
        const Game = {
            state: 'MENU',
            sector: 1,
            frags: 0,
            speed: 0,
            targetLane: 0,
            laneX: [-5, 0, 5],
            upgrades: { magnet: 0, weapon: 0, shield: false },
            
            getCost: (type) => type === 'shield' ? 50 : Math.floor(10 * Math.pow(1.5, Game.upgrades[type])),
            
            buy: (type) => {
                const cost = Game.getCost(type);
                if(Game.frags >= cost) {
                    if(type === 'shield') { if(Game.upgrades.shield) return; Game.upgrades.shield = true; }
                    else { Game.upgrades[type]++; }
                    Game.frags -= cost;
                    AudioSys.play('buy');
                    Game.save(); UI.updateShop();
                }
            },
            save: () => localStorage.setItem('neon_omega_fix', JSON.stringify({frags: Game.frags, upgrades: Game.upgrades})),
            load: () => {
                const d = JSON.parse(localStorage.getItem('neon_omega_fix') || '{}');
                Game.frags = d.frags || 0;
                Game.upgrades = d.upgrades || {magnet:0, weapon:0, shield:false};
            }
        };
        window.Game = Game;

        // --- AUDIO ---
        const AudioSys = {
            ctx: null,
            init() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.3;
                this.master.connect(this.ctx.destination);
                setInterval(() => { if(Game.state === 'RUN' || Game.state === 'BOSS') this.playBass(); }, 250);
            },
            playBass() {
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime([46, 46, 55, 46][Math.floor(t*4)%4], t);
                const g = this.ctx.createGain();
                g.gain.setValueAtTime(0.3, t);
                g.gain.exponentialRampToValueAtTime(0.01, t+0.2);
                osc.connect(g); g.connect(this.master);
                osc.start(t); osc.stop(t+0.2);
            },
            play(id) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                osc.connect(g); g.connect(this.master);
                if(id==='shoot') { osc.frequency.setValueAtTime(600, t); osc.frequency.exponentialRampToValueAtTime(100, t+0.1); g.gain.value=0.1; osc.start(t); osc.stop(t+0.1); }
                else if(id==='coin') { osc.frequency.setValueAtTime(1200, t); osc.frequency.linearRampToValueAtTime(2000, t+0.1); g.gain.exponentialRampToValueAtTime(0.01, t+0.3); osc.start(t); osc.stop(t+0.3); }
                else if(id==='crash') { osc.type='sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t+0.4); g.gain.value=0.4; g.gain.linearRampToValueAtTime(0, t+0.4); osc.start(t); osc.stop(t+0.4); }
                else if(id==='buy') { osc.type='triangle'; osc.frequency.setValueAtTime(440, t); osc.frequency.setValueAtTime(880, t+0.1); g.gain.linearRampToValueAtTime(0, t+0.1); osc.start(t); osc.stop(t+0.1); }
            }
        };

        // --- GRAPHICS ---
        const Scene = {
            init() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.02); // Pitch black fog
                this.camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 4, 8);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                // TONE MAPPING PREVENTS WHITE-OUT
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 0.9;
                document.body.appendChild(this.renderer.domElement);
                
                const renderPass = new RenderPass(this.scene, this.camera);
                this.bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                this.bloom.strength = 1.2; // Reduced from 2.5
                this.bloom.radius = 0.5;
                this.bloom.threshold = 0.2; // Don't bloom everything
                
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(renderPass);
                this.composer.addPass(this.bloom);
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                });
            }
        };

        // --- WORLD ---
        const Terrain = {
            init() {
                const geo = new THREE.PlaneGeometry(200, 200, 80, 80);
                geo.rotateX(-Math.PI/2);
                const mat = new THREE.ShaderMaterial({
                    uniforms: { time: { value: 0 } },
                    vertexShader: `
                        varying vec2 vUv; varying float vElev; uniform float time;
                        void main() {
                            vUv = uv; vec3 p = position;
                            float wave = sin(p.x * 0.1) * 2.0 + sin(p.z * 0.1 + time * 5.0) * 2.0;
                            float mask = smoothstep(5.0, 25.0, abs(p.x));
                            p.y += wave * mask; vElev = p.y;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying float vElev; varying vec2 vUv; uniform float time;
                        void main() {
                            float grid = step(0.97, fract(vUv.x*40.0)) + step(0.97, fract(vUv.y*40.0+time));
                            // Darker floor color
                            vec3 col = mix(vec3(0.05, 0.0, 0.1), vec3(0.0, 0.8, 1.0), grid);
                            col += vec3(1.0, 0.0, 0.5) * (vElev * 0.05);
                            float alpha = 1.0 - smoothstep(0.0, 0.9, distance(vUv, vec2(0.5)));
                            gl_FragColor = vec4(col, alpha);
                        }
                    `,
                    transparent: true
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.y = -2;
                Scene.scene.add(mesh);
                this.mat = mat;
            }
        };

        const Player = {
            mesh: null,
            init() {
                this.mesh = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({
                    color: 0x111111, roughness: 0.4, metalness: 0.8,
                    emissive: 0x00ffff, emissiveIntensity: 0.5 // Reduced emission
                });
                const hull = new THREE.Mesh(new THREE.ConeGeometry(0.5, 2.5, 3), mat);
                hull.rotation.x = Math.PI/2; hull.scale.z = 0.5;
                this.mesh.add(hull);
                
                // Wings
                const wing = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 1), mat);
                wing.position.z = 0.5; this.mesh.add(wing);

                // Shield
                const sGeo = new THREE.IcosahedronGeometry(2, 1);
                const sMat = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true, transparent: true, opacity: 0});
                this.shield = new THREE.Mesh(sGeo, sMat);
                this.mesh.add(this.shield);

                // Engine Trail
                const light = new THREE.PointLight(0x00ffff, 2, 5);
                light.position.set(0,0,2);
                this.mesh.add(light);
                
                Scene.scene.add(this.mesh);
                this.currX = 0; this.tilt = 0;
            },
            update(dt) {
                const tx = Game.laneX[Game.targetLane+1];
                this.currX += (tx - this.currX) * 10 * dt;
                this.mesh.position.x = this.currX;
                this.tilt += (-(this.mesh.position.x - tx)*0.5 - this.tilt) * 10 * dt;
                this.mesh.rotation.z = this.tilt;
                
                if(Game.upgrades.shield) { this.shield.rotation.y += dt; this.shield.material.opacity = 0.3; }
                else this.shield.material.opacity = 0;
            }
        };

        const World = {
            items: [], bullets: [], boss: null,
            spawn(isCoin) {
                const lane = Math.floor(Math.random()*3);
                let m;
                if(isCoin) {
                    m = new THREE.Mesh(new THREE.OctahedronGeometry(0.5), new THREE.MeshBasicMaterial({color: 0xffcc00, wireframe:true}));
                    m.add(new THREE.PointLight(0xffcc00, 1, 3));
                } else {
                    // Obstacle - Darker, red edges
                    const geo = new THREE.BoxGeometry(2, 3, 2);
                    const mat = new THREE.MeshStandardMaterial({color: 0x050505, emissive: 0xff0022, emissiveIntensity: 0.8});
                    m = new THREE.Mesh(geo, mat);
                }
                m.position.set(Game.laneX[lane], 0, -100);
                Scene.scene.add(m);
                this.items.push({mesh:m, type:isCoin?'coin':'obs'});
            },
            spawnBoss() {
                const geo = new THREE.IcosahedronGeometry(4, 1);
                const mat = new THREE.MeshStandardMaterial({color: 0x110000, emissive: 0xff0000, emissiveIntensity: 0.6, wireframe: true});
                const m = new THREE.Mesh(geo, mat);
                m.position.set(0, 5, -50);
                Scene.scene.add(m);
                this.boss = {mesh:m, hp:Game.sector*20, max:Game.sector*20, timer:0};
                UI.showBoss(true);
            },
            update(dt) {
                const spd = Game.speed;
                // Items
                for(let i=this.items.length-1; i>=0; i--) {
                    const it = this.items[i];
                    it.mesh.position.z += spd;
                    if(it.type === 'coin') {
                        it.mesh.rotation.y += dt*2;
                        if(it.mesh.position.distanceTo(Player.mesh.position) < 5 + Game.upgrades.magnet*3) it.mesh.position.lerp(Player.mesh.position, dt*5);
                    }
                    if(it.mesh.position.distanceTo(Player.mesh.position) < 2) {
                        if(it.type === 'coin') { Game.frags++; AudioSys.play('coin'); UI.hud(); Scene.scene.remove(it.mesh); this.items.splice(i,1); }
                        else { Main.hit(); Scene.scene.remove(it.mesh); this.items.splice(i,1); }
                    } else if(it.mesh.position.z > 10) { Scene.scene.remove(it.mesh); this.items.splice(i,1); }
                }
                
                // Boss
                if(this.boss && Game.state === 'BOSS') {
                    this.boss.timer += dt;
                    this.boss.mesh.position.x = Math.sin(this.boss.timer)*10;
                    this.boss.mesh.rotation.y += dt;
                    
                    // Boss Shot
                    if(this.boss.timer % 0.3 < dt) {
                        const b = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,1), new THREE.MeshBasicMaterial({color:0xff0055}));
                        b.position.copy(Player.mesh.position); b.position.y += 0.5; b.position.z = Player.mesh.position.z - 2;
                        Scene.scene.add(b); this.bullets.push({mesh:b, vel:-3, isPlayer:true}); AudioSys.play('shoot');
                    }
                    
                    // Bullet Update
                    for(let i=this.bullets.length-1; i>=0; i--) {
                        const b = this.bullets[i];
                        b.mesh.position.z += b.vel;
                        if(b.mesh.position.distanceTo(this.boss.mesh.position) < 4) {
                            this.boss.hp -= (1+Game.upgrades.weapon);
                            UI.boss(this.boss.hp, this.boss.max);
                            Scene.scene.remove(b.mesh); this.bullets.splice(i,1);
                            if(this.boss.hp <= 0) Main.winBoss();
                        } else if(b.mesh.position.z < -100) {
                            Scene.scene.remove(b.mesh); this.bullets.splice(i,1);
                        }
                    }
                }
            }
        };

        const Main = {
            init() {
                Game.load(); Scene.init(); Terrain.init();
                document.getElementById('start-btn').onclick = () => { AudioSys.init(); this.run(); };
                document.getElementById('respawn-btn').onclick = () => this.run();
                document.addEventListener('keydown', e => {
                    if(e.key=='a'||e.key=='ArrowLeft') Game.targetLane = Math.max(-1, Game.targetLane-1);
                    if(e.key=='d'||e.key=='ArrowRight') Game.targetLane = Math.min(1, Game.targetLane+1);
                });
                this.loop();
            },
            run() {
                Game.state = 'RUN'; Game.speed = 0.8;
                Player.init(); UI.screen(null); UI.hud();
            },
            hit() {
                if(Game.upgrades.shield) {
                    Game.upgrades.shield = false; AudioSys.play('crash');
                    document.getElementById('damage-overlay').style.boxShadow = "inset 0 0 50px #00ff00";
                    setTimeout(()=>document.getElementById('damage-overlay').style.boxShadow="none",200);
                } else {
                    Game.state = 'SHOP'; AudioSys.play('crash');
                    Scene.scene.remove(Player.mesh); UI.screen('shop');
                }
            },
            winBoss() {
                Scene.scene.remove(World.boss.mesh); World.boss = null; UI.showBoss(false);
                Game.sector++; 
                if(Game.sector>=50) { Game.state='END'; UI.screen('endgame'); }
                else { Game.state='RUN'; Game.speed+=0.1; }
                UI.hud();
            },
            loop() {
                requestAnimationFrame(()=>this.loop());
                const dt = 0.016;
                const t = Date.now()*0.001;
                Terrain.mat.uniforms.time.value = t;
                
                if(Game.state === 'RUN' || Game.state === 'BOSS') {
                    Player.update(dt); World.update(dt);
                    if(Game.state === 'RUN') {
                        if(Math.random() < 0.03) World.spawn(Math.random()>0.7);
                        if(Math.random() < 0.003 && Game.sector % 1 === 0) { Game.state = 'BOSS'; World.spawnBoss(); }
                    }
                }
                Scene.composer.render();
            }
        };

        const UI = {
            hud: () => {
                document.getElementById('score-hud').innerText = `SECTOR ${Game.sector}`;
                document.getElementById('currency-hud').innerText = `${Game.frags} FRAGMENTS`;
            },
            boss: (hp, max) => document.getElementById('boss-bar').style.width = (hp/max*100)+'%',
            showBoss: (s) => document.getElementById('boss-frame').style.display = s?'block':'none',
            screen: (id) => {
                document.querySelectorAll('.screen').forEach(e=>e.classList.add('hidden'));
                if(id) { document.getElementById(id).classList.remove('hidden'); if(id==='shop') this.shop(); }
            },
            shop: () => {
                document.getElementById('shop-frags').innerText = Game.frags;
                document.getElementById('lvl-mag').innerText = Game.upgrades.magnet;
                document.getElementById('lvl-wep').innerText = Game.upgrades.weapon;
                document.getElementById('cost-mag').innerText = Game.getCost('magnet');
                document.getElementById('cost-wep').innerText = Game.getCost('weapon');
                const sl = document.getElementById('lvl-shi');
                sl.innerText = Game.upgrades.shield?"ACTIVE":"OFFLINE"; sl.style.color=Game.upgrades.shield?"#00ff00":"#fff";
            }
        };

        Main.init();
    </script>
</body>
</html>
